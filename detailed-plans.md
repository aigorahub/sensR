sensPy - Detailed Execution Plan to Port sensRBased on: Final Technical Plan for Porting sensR to Python as sensPy (Version 1.0)Objective: To provide a granular, step-by-step guide for the development team to execute the porting of sensR to sensPy.Assumptions:Team Composition (Illustrative):Dev1 (Lead Python Developer, System Architect)Dev2 (Python Developer, Testing Focus)Statistician (Domain Expert, R & Python Validation)Doc Specialist (Part-time, Technical Writer)Sprint Length: 1 week (tasks may span multiple weeks/sprints).Project Management: Agile methodology. Regular stand-ups, sprint planning, and reviews.Tools: Git (GitHub), Poetry, Pytest, Sphinx, Numba, JAX/Numdifftools, RPy2, Task Management (e.g., Jira, GitHub Issues), Communication (e.g., Slack).Sprint 0: Pre-Development Setup (1 Week - Concurrent with Phase 1, Week 1)Objective: Establish foundational project infrastructure, onboard team, and initiate critical upfront activities.Tasks:Team Onboarding & Kick-off Meeting (All Hands):Review this Execution Plan and the main Technical Plan.Clarify roles, responsibilities, and communication protocols (daily stand-ups, weekly planning/review).Define development workflows (feature branches, PRs, code review standards).Version Control Setup (Dev1):Create the sensPy Git repository (e.g., on GitHub).Initialize main and develop branches.Set up branch protection rules.Create initial .gitignore (Python template) and LICENSE (GPL-2.0-or-later placeholder, to be confirmed).Task Management System Setup (Dev1/Project Lead):Set up project board (e.g., GitHub Projects).Populate backlog with high-level tasks from Phases 1 & 2.Initial Legal Consultation (Project Lead/Dev1):Schedule and conduct initial meeting with legal expert regarding GPL-2.0-or-later obligations and third-party library compatibility.PyPI Placeholder Registration (Dev1):Create minimal pyproject.toml for senspy.Add README.md: "This is a placeholder for senspy; do not depend on this version."Register senspy on PyPI and publish senspy==0.0.1 (or 0.0.0).Development Environment Setup (Dev1, Dev2, Statistician):Install Python 3.8+, Poetry, Git.Set up local virtual environments for sensPy.Install R, sensR package, and RPy2.Verify RPy2 connectivity.Initial sensR Code Familiarization (All Technical Team):Clone sensR repository.Begin high-level review of R code structure, focusing on key files identified in the Technical Plan.Phase 1: Setup and Detailed Analysis (4 Weeks Total)Overall Objective: Establish project infrastructure, thoroughly analyze sensR, define detailed scope, and prepare for core development.Week 1 (Phase 1, Week 1 of 4) - Project Kickstart & Deep DiveGoal(s): Formalize project setup, initiate sensR deep dive, start Functionality Inventory.Detailed Steps/Tasks:Dev1: Finalize Git repository setup (issue templates, PR templates, contribution guidelines draft).Dev1, Dev2: Set up initial Python project structure using poetry init for sensPy (as per Technical Plan directory structure). Include CITATION.cff placeholder.Statistician, Dev1: Begin detailed line-by-line review of sensR/R/psyfun.R and sensR/R/rescale.R. Document algorithms, inputs, outputs, and edge cases. Start populating the Functionality Inventory spreadsheet for these.Dev2: Begin detailed line-by-line review of sensR/R/discrim.R (focus on core logic and one simple protocol like 2-AFC). Document algorithms, inputs, outputs. Add to Functionality Inventory.Doc Specialist: Start drafting outline for the Legal FAQ based on initial consultation points and GPL-2.0-or-later.All: Daily stand-ups.Checkpoints:sensPy repository created with basic structure.Functionality Inventory started for psyfun, rescale, and parts of discrim.Week 2 (Phase 1, Week 2 of 4) - Mapping & DependenciesGoal(s): Complete initial sensR file reviews, map data structures, analyze R dependencies.Detailed Steps/Tasks:Statistician, Dev1: Complete review of sensR/R/betaBin.R. Document algorithms, statistical formulas, optimization methods used. Add to Functionality Inventory.Dev2: Complete review of sensR/R/twoAC.R and other key discrimination protocol helpers. Add to Functionality Inventory.Dev1: Lead effort on Data Structure Mapping: Document how R vectors, lists, data.frames, and S3/S4 objects in sensR will map to Python (NumPy arrays, lists/dicts, Pandas DataFrames, custom classes). Create a reference document.Dev2: Analyze sensR DESCRIPTION file and code for all R package dependencies (stats, MASS, numDeriv, multcomp). Research and document Python equivalents (e.g., scipy.stats, statsmodels, jax/numdifftools).Doc Specialist: Continue drafting Legal FAQ.All: Daily stand-ups. Weekly review of progress on Functionality Inventory and Mappings.Checkpoints:Initial review of all key sensR files complete.Draft Data Structure Mapping document created.Draft R Dependency to Python Equivalents document created.Week 3 (Phase 1, Week 3 of 4) - CI Setup & Legal DraftGoal(s): Set up basic CI, finalize Legal FAQ draft, refine project structure.Detailed Steps/Tasks:Dev1: Set up basic GitHub Actions CI pipeline:Trigger on push to develop and PRs to main/develop.Include steps for Python linting (flake8, black).Include basic pytest execution (even with no tests yet, just to ensure pipeline works).Set up for Linux-latest and Windows-latest runners.Dev2: Start creating placeholder Python files in senspy/ directory structure (links.py, models.py, etc.) with basic module docstrings.Doc Specialist, Project Lead: Finalize draft of Legal FAQ for internal review, incorporating feedback from legal consultation if available.Statistician: Begin creating test cases (input data, expected sensR output) for psyfun and rescale based on sensR examples and documentation. Store these in a structured way (e.g., CSV files, JSON).All: Daily stand-ups.Checkpoints:Basic CI pipeline operational (linting, placeholder tests).Legal FAQ draft ready for review.Initial test cases for psyfun, rescale documented.Week 4 (Phase 1, Week 4 of 4) - Finalize Phase 1 & Plan Phase 2Goal(s): Complete all Phase 1 deliverables, review, and plan initial sprints for Phase 2.Detailed Steps/Tasks:All: Review and finalize Functionality Inventory, Data Structure Mapping, and R Dependency documents.Dev1: Ensure PyPI placeholder senspy==0.0.1 is live and correct.Project Lead/Dev1: Confirm legal consultation outcomes are integrated into planning.All: Phase 1 Review Meeting. Present deliverables, discuss challenges and learnings.All: Sprint Planning for Phase 2 (Weeks 5-6 / Sprints 1-2 of Phase 2). Assign tasks for implementing psychometric functions.Deliverables Checklist for Phase 1 Completion:[x] Project repository with GPL-2.0-or-later license.[x] Functionality Inventory and Data Structure Mapping documents.[ ] Legal FAQ draft.[ ] PyPI placeholder package live.[x] CI configuration for Linux/Windows (basic).Phase 2: Core Functionality and Foundational Utilities (8 Weeks Total)Overall Objective: Implement core statistical models, psychometric functions, and protocol-specific functions with performance optimizations.Weeks 5-6 (Phase 2, Sprints 1-2) - Psychometric FunctionsGoal(s): Implement and test psyfun, psyinv, psyderiv, rescale.Detailed Steps/Tasks:Dev1: Implement psyfun in senspy/links.py. Write comprehensive docstrings.Dev2: Implement psyinv in senspy/links.py. Write comprehensive docstrings.Statistician: Provide R code snippets / RPy2 calls to generate expected outputs for a wide range of psyfun and psyinv inputs (various methods, d-primes, PCs).Dev1, Dev2: Write unit tests for psyfun and psyinv using pytest, comparing outputs against sensR via RPy2 or pre-calculated values. Aim for |Δ| ≤ 1e-12.Dev1: Implement psyderiv in senspy/links.py. Write docstrings.Dev2: Implement rescale (core logic for value conversion) in senspy/links.py. Write docstrings.Statistician: Provide test cases for psyderiv and rescale (value conversion part).Dev1, Dev2: Unit test psyderiv and rescale (value conversion).Dev1: Implement standard error calculations for rescale (this may involve using psyderiv).Statistician, Dev2: Validate rescale standard error calculations against sensR. Write unit tests.All: Code reviews for all implemented functions. Ensure CI passes.Checkpoints:psyfun, psyinv, psyderiv, rescale implemented and unit tested.Numerical fidelity confirmed against sensR.Weeks 7-8 (Phase 2, Sprints 3-4) - Beta-Binomial ModelGoal(s): Implement and test beta_bin (standard and chance-corrected), including Numba optimization.Detailed Steps/Tasks:Dev1: Implement the Python structure for beta_bin in senspy/models.py (function signature, parameter handling, ValueError for p_guess). Refer to the "Revised Beta-Binomial Code Artifact".Dev1: Implement the _standard_loglik helper function using Numba (@jit(nopython=True)).Dev2: Implement the log_binom_pmf and numba_betaln helper functions using Numba.Dev1: Implement the _corrected_loglik_terms helper function using Numba, ensuring correct use of log_binom_pmf (with x_obs as size) and log_terms_buffer.Statistician: Provide diverse test datasets for beta_bin (standard and corrected), including inputs that test edge cases for p_guess, x, and n. Provide corresponding sensR outputs (coefficients, loglik).Dev2: Write unit tests for standard beta_bin. Validate coefficients and log-likelihood against sensR outputs (|Δ| ≤ 1e-12 for coeffs, |Δ| ≤ 1e-9 for loglik).Dev1: Integrate scipy.optimize.minimize (L-BFGS-B) for parameter estimation. Handle vcov extraction.Dev2: Write unit tests for chance-corrected beta_bin. Validate as above.All: Code review, focusing on Numba implementation, statistical correctness, and numerical stability (log-sum-exp).Dev1, Dev2: Refactor beta_bin into a class BetaBinomial inheriting from a basic BaseModel stub.Checkpoints:beta_bin (standard and corrected) implemented and Numba-optimized.Validated against sensR for coefficients and log-likelihood.Initial BetaBinomial class structure in place.Weeks 9-10 (Phase 2, Sprints 5-6) - discrim Core & Initial ProtocolsGoal(s): Implement core discrim logic and support for 1-2 simple discrimination protocols (e.g., 2-AFC, Triangle). Stub out likelihood/score/Wald tests.Detailed Steps/Tasks:Dev1: Design and implement the main discrim function signature in senspy/discrimination.py. Handle common parameters (correct, total, method, conf.level, etc.).Dev1: Implement d-prime, Pc, Pd estimation logic within discrim for the "2-AFC" method, using psyfun/psyinv.Statistician: Provide sensR discrim(..., method="twoAFC") outputs for various correct/total inputs.Dev2: Write unit tests for discrim with "2-AFC", validating estimates.Dev1: Implement d-prime, Pc, Pd estimation logic for the "Triangle" method.Statistician: Provide sensR discrim(..., method="triangle") outputs.Dev2: Write unit tests for discrim with "Triangle".Dev1: Stub out the structures for calculating standard errors and p-values using "exact", "likelihood", "score", "Wald" statistics. Initially, "exact" (binomial-based) can be implemented for p-values.Dev2: Implement "exact" p-value calculation for discrim based on binomial tests. Validate.Statistician: Review statistical formulas for SEs and CIs for likelihood, score, Wald tests as per sensR logic.All: Code reviews.Checkpoints:discrim function can estimate d', Pc, Pd for 2-AFC and Triangle methods."Exact" p-values implemented for discrim.Stubs for advanced statistical tests and CIs in place.Weeks 11-12 (Phase 2, Sprints 7-8) - 2-AC Protocol, API, Utilities, Compiler MilestoneGoal(s): Implement 2-AC protocol, define BaseModel API, implement utilities, and meet compiler milestone.Detailed Steps/Tasks:Dev1: Implement the twoAC specific logic in senspy/discrimination.py (or a dedicated module if complex). This includes:Likelihood function for d_prime and tau.Reparameterization of tau using tanh(φ).Use scipy.optimize.minimize (L-BFGS-B) with analytic gradients (derived by Statistician/Dev1).Statistician: Derive analytic gradients for the 2-AC likelihood. Provide sensR twoAC outputs for validation.Dev2: Write unit tests for twoAC, validating parameter estimates and log-likelihood.Dev1: Define the BaseModel abstract base class in senspy/models.py with abstract methods fit, summary, confint.Dev1: Refactor BetaBinomial and create DiscriminationResult (or similar for discrim outputs) to inherit from/use BaseModel structure. Implement basic summary() method for BetaBinomial (coeffs, loglik). summary() for DiscriminationResult should show d', Pc, Pd, p-value. Implement vcov dimensionality check in summary().Dev2: Implement senspy.utils.has_jax() and senspy.version() in senspy/__init__.py or senspy/utils.py. Write tests for these.Dev1, Dev2: Compiler Milestone Execution:Run pytest -k "beta_bin or discrim" on Linux/Windows with NUMBA_DISABLE_JIT=0, NUMBA_OPT=3. Verify all tests pass.Run same tests with NUMBA_DISABLE_JIT=1. Verify all tests pass (will be slower).Benchmark: beta_bin(corrected=False) on a 10,000-draw dataset. Ensure execution time < 0.2s on GitHub runner (or agreed target). Document results.Doc Specialist: Begin drafting documentation for implemented psychometric functions and beta_bin.All: Code reviews. Phase 2 review meeting. Plan Phase 3 Sprints.Deliverables Checklist for Phase 2 Completion:[ ] links.py, models.py, discrimination.py, utils.py significantly implemented.[x] psyfun, psyinv, psyderiv, rescale complete.[ ] beta_bin (standard & corrected) complete and Numba-optimized.[ ] discrim core logic with 2-AFC, Triangle, and exact p-values.[ ] twoAC protocol implemented.[ ] BaseModel API defined; BetaBinomial and DiscriminationResult use it.[x] has_jax(), version() utilities implemented.[ ] Unit tests with RPy2 validation for implemented features.[ ] Compiler milestone report.[ ] Draft documentation for core functions.Phase 3: Statistical Computations and Visualization (6 Weeks Total)Overall Objective: Implement advanced statistical computations (power, sample size, complex CIs) and visualization capabilities.Weeks 13-14 (Phase 3, Sprints 9-10) - Sample Size & PowerGoal(s): Implement discrimSS (sample size) and discrimPwr (power) functionalities, including exact_power_binom.Detailed Steps/Tasks:Dev1: Design senspy/power.py module structure.Dev1: Implement exact_power_binom function using scipy.optimize.brentq for root-finding on exact binomial probabilities (for small n >= 5). Ensure signature matches plan: PowerResult = namedtuple("PowerResult", ["power", "n", "alpha", "method"]).Statistician: Provide test cases for exact_power_binom by comparing with sensR or other known statistical software/tables.Dev2: Write unit tests for exact_power_binom.Dev1: Implement core logic for discrimPwr (calculating power). For "exact" statistic, use exact_power_binom. For normal approximations (large n), use statsmodels.stats.power or direct formulas.Dev2: Implement core logic for discrimSS (calculating sample size). This often involves iterating discrimPwr or inverting power formulas.Statistician: Provide comprehensive test cases for discrimPwr and discrimSS across different methods, effect sizes, alpha, power levels, from sensR.Dev1, Dev2: Write unit tests for discrimPwr and discrimSS, validating against sensR.All: Code reviews.Checkpoints:exact_power_binom implemented and tested.discrimPwr and discrimSS implemented for key statistics/methods and tested.Weeks 15-16 (Phase 3, Sprints 11-12) - Profile Likelihood CIsGoal(s): Implement profile likelihood confidence intervals, initially for discrim results.Detailed Steps/Tasks:Dev1, Statistician: Deep dive into sensR's profile likelihood CI calculation for discrim. Understand how nuisance parameters are handled and how the likelihood is profiled.Dev1: Implement the log-likelihood function for d-prime (parameter of interest in discrim) for a specific protocol (e.g., 2-AFC). This function will need to take data and potentially nuisance parameters.Dev1: Implement the profiling mechanism:For a fixed d-prime, optimize out nuisance parameters (if any for the chosen model/protocol) to get the profiled log-likelihood value. Use scipy.optimize.minimize.Define the target function: profile_loglik(d_prime) - (max_loglik - chisq.ppf(conf_level, 1)/2).Dev1: Use scipy.optimize.brentq (or another root-finder) to find the d-prime values (lower and upper CI bounds) where the target function is zero.Statistician: Provide test cases: sensR profile likelihood CI outputs for discrim with 2-AFC.Dev2: Write unit tests for the profile likelihood CI calculation for discrim (2-AFC method).Dev1: Extend profile likelihood CI implementation to another protocol (e.g., Triangle).Dev2: Add unit tests for Triangle method profile CIs.All: Code reviews, focusing on numerical stability and correctness of the optimization procedures.Checkpoints:Profile likelihood CIs implemented and tested for discrim with at least two methods.Weeks 17-18 (Phase 3, Sprints 13-14) - VisualizationGoal(s): Implement static (matplotlib) and optional interactive (Plotly) plotting functions.Detailed Steps/Tasks:Dev1: Design senspy/plotting.py module.Dev1: Implement a matplotlib-based function to plot discrim results (e.g., d-prime with CIs). Function should accept a DiscriminationResult object.Dev2: Implement a matplotlib-based function to plot discrimination curves (e.g., Pc vs. stimulus level, if applicable data is part of results).Statistician: Provide examples of plots generated by sensR for comparison.Dev1: Implement Plotly-based versions of the above plots. Ensure Plotly is an optional dependency (try/except ImportError). Plotting functions should return raw data if Plotly is not available or if requested, for use with other renderers.Doc Specialist: Draft documentation for plotting functions, including examples of both matplotlib and Plotly outputs.Dev2: Write basic tests for plotting functions (e.g., check if a plot object is created, no runtime errors. Visual inspection will be key).All: Code reviews. Phase 3 review meeting. Plan Phase 4 Sprints.Deliverables Checklist for Phase 3 Completion:[ ] power.py and plotting.py modules implemented.[ ] Sample size and power calculations functional and tested.[ ] Profile likelihood CIs implemented for key models.[ ] Static (matplotlib) and interactive (Plotly) plotting functions available.[ ] Unit tests and plot examples for new features.[ ] Updated documentation.Phase 4: Testing and Validation (5 Weeks Total - Partially concurrent)Overall Objective: Ensure numerical fidelity, robustness, and high code coverage through comprehensive and rigorous testing.Weeks 19-20 (Phase 4, Sprints 15-16) - Comprehensive Test Suite DevelopmentGoal(s): Develop comprehensive RPy2 validation scripts, edge case tests, and property-based tests.Detailed Steps/Tasks:Statistician, Dev2: Systematically create R scripts that run all core sensR functions (identified in Functionality Inventory) with a wide variety of valid inputs, saving their detailed outputs (estimates, SEs, CIs, p-values, log-likelihoods) to structured files (e.g., JSON, CSV).Dev2: Develop Python test scripts using pytest and RPy2 to:Load the same input data used for sensR.Call the corresponding sensPy functions.Compare sensPy outputs against saved sensR outputs using specified tolerances.Dev1: Identify and document a library of edge cases for each major function (e.g., correct=0, correct=total, p_guess near 0 or 1, small N, zero variance data). Implement these as unit tests.Dev2: Integrate hypothesis for property-based testing for key numerical functions (e.g., psyfun/psyinv relationship, beta_bin parameter recovery from simulated data). Configure max_examples=50 for CI, max_examples=500 for nightly runs.All: Contribute to expanding test coverage for all modules.Checkpoints:RPy2 validation framework established.Initial set of edge case tests implemented.Property-based tests for 1-2 key functions.Week 21 (Phase 4, Sprint 17) - Full Test Execution & DebuggingGoal(s): Execute the full test suite, identify discrepancies, and debug.Detailed Steps/Tasks:Dev1, Dev2: Run the entire test suite (unit, RPy2 validation, edge cases, property-based) on CI (Linux, Windows).All: Triage any failing tests. Prioritize debugging based on severity.Dev1, Dev2, Statistician: Collaboratively investigate numerical discrepancies between sensPy and sensR. Determine if differences are acceptable (within tolerance, due to optimizer differences) or indicate bugs.Doc Specialist: Begin documenting known limitations or minor numerical differences if deemed acceptable.Checkpoints:Full test suite executed at least once.Major bugs and discrepancies identified and logged.Week 22 (Phase 4, Sprint 18) - Performance & Precision DocumentationGoal(s): Conduct performance benchmarking and document achieved numerical precision.Detailed Steps/Tasks:Dev1: Conduct performance benchmarks for computationally intensive functions (e.g., beta_bin, discrim with profile likelihood CIs) on representative datasets. Compare Numba vs. non-Numba versions where applicable.Dev2: Systematically document the achieved precision for each validated function against sensR in the Validation Report.Statistician: Review precision documentation for statistical soundness.Dev1: Ensure reproducibility settings (fixed seeds, BLAS environment variables) are effective and documented.Checkpoints:Performance benchmark results documented.Achieved precision for key functions documented.Week 23 (Phase 4, Sprint 19) - Final Validation & ReportingGoal(s): Finalize validation, achieve target test coverage, and complete validation report.Detailed Steps/Tasks:Dev1, Dev2: Address any remaining high-priority bugs identified from testing.Dev2: Use coverage tools (e.g., pytest-cov) to measure test coverage. Add tests to reach target 95% coverage.All: Review and finalize the Validation Report, summarizing test results, numerical comparisons, performance, and known limitations.All: Phase 4 Review Meeting. Plan Phase 5 Sprints.Deliverables Checklist for Phase 4 Completion:[ ] Test suite with 95% coverage.[ ] Validation report comparing sensPy to sensR (including precision documentation).[ ] Performance benchmarks documented.[ ] All critical bugs resolved.Phase 5: Documentation and Packaging (3 Weeks Total - Partially concurrent)Overall Objective: Produce comprehensive documentation and a distributable PyPI package.Week 24 (Phase 5, Sprint 20) - API Docs, Tutorials, Migration GuideGoal(s): Generate API documentation, write initial tutorials, and draft migration guide.Detailed Steps/Tasks:Doc Specialist, Dev1: Set up Sphinx documentation framework. Configure to pull from docstrings.All Devs: Ensure all public functions, classes, and methods have comprehensive docstrings (NumPy/Google style).Doc Specialist: Write initial tutorials for common use cases (e.g., analyzing a 2-AFC test, fitting a beta-binomial model).Doc Specialist, Statistician: Draft the "R (sensR) to Python (sensPy) Migration Guide" with function/parameter equivalence tables.Dev1: Implement senspy.utils.has_jax() and senspy.version() if not already completed from Phase 2. Ensure senspy.version() is used in notebook examples.Checkpoints:Sphinx setup complete; initial API docs generated.Draft of 2-3 tutorials.Draft of Migration Guide.Week 25 (Phase 5, Sprint 21) - Notebooks, Contribution Docs, CITATION.cffGoal(s): Create interactive notebooks, finalize contribution guidelines, and add CITATION.cff.Detailed Steps/Tasks:Dev2, Statistician: Create Colab/Binder-ready Jupyter notebooks for each major discrimination protocol, demonstrating sensPy usage and plotting. Ensure senspy.version() is printed.Doc Specialist: Finalize contribution guidelines (CONTRIBUTING.md) and Code of Conduct (CODE_OF_CONDUCT.md).Dev1: Create CITATION.cff file for Zenodo DOI generation.Doc Specialist: Document vcov as L-BFGS-B approximation, reproducibility settings (BLAS, Docker), and Plotly headless server behavior.Checkpoints:Interactive notebooks for key protocols created.Contribution guidelines and CoC finalized.CITATION.cff created.Week 26 (Phase 5, Sprint 22) - Final Packaging & ReadTheDocsGoal(s): Finalize pyproject.toml, build PyPI package, test installation, and set up ReadTheDocs.Detailed Steps/Tasks:Dev1: Finalize pyproject.toml with all dependencies, extras, metadata, keywords, homepage/repository URLs (use placeholders if final URLs not ready).Dev1: Build source (sdist) and wheel (bdist_wheel) distributions using poetry build.Dev2: Test installation of the built packages in clean virtual environments on Linux and Windows. Test optional dependencies.Doc Specialist, Dev1: Set up ReadTheDocs project for sensPy. Configure webhook with GitHub repository. Ensure documentation builds correctly.Dev1: Add README badges (PyPI version, license, tests, docs, Zenodo DOI placeholder).All: Final review of all documentation. Phase 5 Review Meeting. Plan Phase 6.Deliverables Checklist for Phase 5 Completion:[ ] PyPI package (senspy==0.1.0 built and tested, not yet published).[ ] ReadTheDocs documentation live.[ ] Colab/Binder notebooks complete.[ ] CITATION.cff and README badges in place.[ ] CI/CD pipeline for tests and docs fully operational.Phase 6: Community Feedback and Iteration (4 Weeks Total)Overall Objective: Release a beta version, gather community feedback, address critical issues, and prepare for a stable v1.0.0 release.Week 27 (Phase 6, Sprint 23) - Beta Release & AnnouncementGoal(s): Publish beta version to PyPI and announce call for feedback.Detailed Steps/Tasks:Dev1: Tag v0.1.0-beta.1 (or similar) in Git.Dev1: Publish the senspy beta package to PyPI using poetry publish.Project Lead/Doc Specialist: Announce the beta release and call for community feedback on relevant channels (e.g., mailing lists, forums, social media for sensory science/Python stats). Link to the documentation, GitHub issues, and the Technical Plan webpage.All Team: Prepare to monitor GitHub issues and other feedback channels.Checkpoints:senspy beta version live on PyPI.Community announcement made.Weeks 28-29 (Phase 6, Sprints 24-25) - Feedback Collection & Bug FixingGoal(s): Actively collect user feedback, triage issues, fix critical bugs, and implement high-priority improvements.Detailed Steps/Tasks:All Team: Monitor GitHub issues, emails, and other channels for feedback. Respond promptly.Project Lead/Dev1: Triage reported bugs and feature requests. Prioritize based on impact and feasibility.Dev1, Dev2: Work on fixing critical bugs identified by the community or internal testing.Dev1, Dev2: Implement any high-priority, small-scope feature enhancements based on feedback.Doc Specialist: Update documentation based on user questions and clarifications.Statistician: Review any statistical concerns raised by users.Consider releasing v0.1.0-beta.2 if significant changes are made.Checkpoints:Feedback actively being collected and triaged.Critical bugs addressed.Week 30 (Phase 6, Sprint 26) - Final Testing & GA GatingGoal(s): Conduct final testing on the release candidate, ensure GA criteria are met.Detailed Steps/Tasks:Dev1, Dev2: Create a release candidate branch for v1.0.0.Dev2: Run the full test suite (including RPy2 validation and property-based tests) on the release candidate.All Team: GA Gating Check:Verify 95%+ test coverage.Verify all profile likelihood CI tests are passing with documented precision.Confirm no critical open bugs.Ensure documentation is complete and accurate.Dev1: Address any final issues identified during GA gating.Project Lead: Make go/no-go decision for v1.0.0 release.Dev1: (If go) Tag v1.0.0 in Git.Checkpoints:Release candidate passes all tests.GA criteria met and signed off.Week 31-34 (Buffer & Post-GA Polish - Part of 10% Contingency)Goal(s): Publish v1.0.0, post-release monitoring, backlog grooming.Detailed Steps/Tasks:Dev1: Publish senspy==1.0.0 to PyPI.Project Lead/Doc Specialist: Announce the stable v1.0.0 release. Update Zenodo DOI via CITATION.cff if necessary.All Team: Monitor for any immediate post-release issues.Dev1, Dev2: Address backlog items like optimizing standard likelihood loop in beta_bin or investigating sandwich estimators for vcov if deemed necessary from feedback.Doc Specialist: Finalize community contribution guidelines.Deliverables Checklist for Phase 6 Completion (and Project Launch):[ ] Stable release (senspy==1.0.0) live on PyPI.[ ] Community contribution guidelines finalized.[ ] Project officially launched.This detailed execution plan provides a week-by-week guide. Actual progress may vary, and the agile nature of the project allows for adjustments based on findings and feedback during each sprint/phase review.
